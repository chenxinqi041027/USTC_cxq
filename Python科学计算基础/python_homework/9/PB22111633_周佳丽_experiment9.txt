##### start of Listing 9.1 ##### import mathimport matplotlib.pyplot as pltclass Integrator:    def __init__(self, a, b, n):        self.a, self.b, self.n = a, b, n        self.points, self.weights = self.compute_points()    def compute_points(self):        raise NotImplementedError(self.__class__.__name__)    def integrate(self, f):          I = 0        for i in range(0, self.n + 1):            I += self.weights[i] * f(self.points[i])        return Iclass Trapezoidal(Integrator):    def compute_points(self):        h = (self.b - self.a) / self.n        weights = []; points = []        for i in range(0, self.n + 1):            weights.append(h)            points.append(self.a + i * h)        weights[0] = weights[self.n] = h / 2        return points, weights        class Simpson(Integrator):    def compute_points(self):          if self.n % 2:            self.n += 1        h = (self.b - self.a) / self.n        weights = []; points = []        for i in range(0, self.n + 1):            points.append(self.a + i * h)        weights.append(h / 3)        for i in range(1, self.n, 2):            weights.append(4 * h / 3)            weights.append(2 * h / 3)        weights.append(h / 3)        return points, weightsclass GaussLegendre(Integrator):    def compute_points(self):          if self.n % 2 == 0:            self.n += 1        h = 2 * (self.b - self.a) / (self.n  + 1)        weights = []; points = []        for i in range(0, self.n, 2):            points.append(self.a + (i + 1) / 2 * h - math.sqrt(3) / 6 * h)            points.append(self.a + i / 2 * h + math.sqrt(3) / 6 * h)        for i in range(0, self.n + 1):            weights.append(h / 2)        return points, weights    def f(x):    return (x * math.cos(x) + math.sin(x)) * math.exp(x * math.sin(x))def F(x):    return math.exp(x * math.sin(x))I_exact = F(3) - F(2)x = [2, 4, 8, 16, 32, 64, 128, 256]y_1 = []; y_2 = []; y_3 = []for i in x:    integrator = Trapezoidal(2, 3, i)    y_1.append(abs((I_exact - integrator.integrate(f)) / I_exact))    integrator = Simpson(2, 3, i)    y_2.append(abs((I_exact - integrator.integrate(f)) / I_exact))    integrator = GaussLegendre(2, 3, i)    y_3.append(abs((I_exact - integrator.integrate(f)) / I_exact))    plt.plot(x, y_1, color = 'y', label = 'Trapezoidal')plt.plot(x, y_2, color = 'g', label = 'Simpson')plt.plot(x, y_3, color = 'r', label = 'GaussLegendre')plt.ylabel('relative error')plt.xlabel('n')plt.title("definite integral")plt.legend()plt.grid(linestyle = ':')plt.show()##### end of Listing 9.1 ##### ##### start of Listing 9.2 ##### import numpy as npimport matplotlib.pyplot as pltx = np.arange(100, 1005, 100)y1 = [0.0004, 0.0016, 0.0034, 0.0063, 0.0104, 0.0153, 0.0209, 0.0275, 0.0355, 0.0437] y2 = [0.0002, 0.0005, 0.0008, 0.0011, 0.0013, 0.0017, 0.0020, 0.0023, 0.0025, 0.0029] y3 = [0.0001, 0.0003, 0.0004, 0.0006, 0.0007, 0.0009, 0.0011, 0.0013, 0.0015, 0.0017]plt.figure(figsize = (8, 4), dpi = 300)plt.xticks(x)# 插入排序plt.plot(x, y1, color = 'y', label = 'insertion_sort')# 归并排序plt.plot(x, y2, color = 'r', label = 'merge_sort')# 快速排序plt.plot(x, y3, color = 'g', label = 'qsort')plt.ylabel('time')plt.xlabel('n')plt.title("Three types of sorting")plt.legend()plt.grid(linestyle = ':')plt.show()##### end of Listing 9.2 ##### ##### start of Listing 9.3 ##### import numpy as npimport matplotlib as mplimport matplotlib.pyplot as pltdef title_and_labels(ax, title):    ax.set_title(title)    ax.set_xlabel("$x$")    ax.set_ylabel("$y$")    ax.set_zlabel("$z$")    fig, axes = plt.subplots(2, 2, figsize = (6, 6), subplot_kw = {'projection': '3d'})x = y = np.linspace(-2, 2, 100)X, Y = np.meshgrid(x, y)Z = (3 * (X**3) - 2 * X + 4 * (X**2) * Y + 2 * (Y**2)) * np.exp(- X**2 - Y**2)# 根据z值染色的表面图norm = mpl.colors.Normalize(vmin = Z.min(), vmax = Z.max())p = axes[0, 0].plot_surface(X, Y, Z, linewidth=0, rcount=20,                            ccount=20, norm=norm,                            cmap=mpl.cm.hot)cb = fig.colorbar(p, ax=axes[0, 0], pad=0.1, shrink = 0.6)title_and_labels(axes[0, 0], "surface plot")# x坐标值相同的点连线得到的三维等高线图cset = axes[0, 1].contour(X, Y, Z, zdir = 'x', levels = 20,                          norm = norm, cmap = mpl.cm.hot)title_and_labels(axes[0, 1], "contour x")# y坐标值相同的点连线得到的三维等高线图cset = axes[1, 0].contour(X, Y, Z, zdir = 'y', levels = 20,                          norm = norm, cmap = mpl.cm.hot)title_and_labels(axes[1, 0], "contour y")#z坐标值相同的点连线得到的三维等高线图cset = axes[1, 1].contour(X, Y, Z, zdir = 'z', levels = 20,                          norm = norm, camp = mpl.cm.hot)title_and_labels(axes[1, 1], "contour z")fig.tight_layout(); plt.show()##### end of Listing 9.3 ##### 